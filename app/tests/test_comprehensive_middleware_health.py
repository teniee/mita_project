"""
Comprehensive Middleware Health Check Testing Framework
Tests designed to validate health checks can detect issues that could cause 8-15+ second timeouts
"""

import pytest
import asyncio
import time
import logging
from datetime import datetime, timedelta
from unittest.mock import Mock, patch, AsyncMock
from sqlalchemy.ext.asyncio import AsyncSession
import redis
import json
from typing import Dict, Any, List

from app.core.middleware_health_monitor import (
    middleware_health_monitor, 
    MiddlewareHealthMonitor,
    HealthStatus,
    HealthMetric
)
from app.core.middleware_components_health import (
    SecurityMiddlewareHealthChecker,
    DatabaseMiddlewareHealthChecker,
    CacheMiddlewareHealthChecker
)
from app.core.health_monitoring_alerts import (
    health_alert_manager,
    HealthAlertManager,
    Alert,
    AlertSeverity
)
from app.api.health.enhanced_routes import router

logger = logging.getLogger(__name__)


class TestMiddlewareHealthMonitor:
    """Test the comprehensive middleware health monitoring system"""

    @pytest.fixture
    def health_monitor(self):
        """Create a fresh health monitor instance for testing"""
        return MiddlewareHealthMonitor()

    @pytest.fixture
    async def mock_session(self):
        """Mock database session for testing"""
        session = AsyncMock(spec=AsyncSession)
        
        # Mock basic connectivity test
        mock_result = Mock()
        mock_result.scalar.return_value = 1
        session.execute.return_value = mock_result
        
        # Mock connection pool stats
        mock_pool_result = Mock()
        mock_pool_result.first.return_value = Mock(
            total_connections=10,
            active_connections=5,
            idle_connections=5,
            idle_in_transaction=0,
            long_running_queries=0,
            very_long_queries=0,
            max_query_duration_seconds=1.5
        )
        
        # Configure session.execute to return different results based on SQL
        async def mock_execute(sql):
            sql_text = str(sql)
            if "SELECT 1" in sql_text:
                return mock_result
            elif "pg_stat_activity" in sql_text:
                return mock_pool_result
            else:
                return mock_result
        
        session.execute.side_effect = mock_execute
        return session

    async def test_comprehensive_health_check_healthy_system(self, health_monitor, mock_session):
        """Test health check on a healthy system"""
        # Run comprehensive health check
        report = await health_monitor.run_comprehensive_middleware_health_check(mock_session)
        
        # Verify report structure
        assert report is not None
        assert hasattr(report, 'overall_status')
        assert hasattr(report, 'metrics')
        assert hasattr(report, 'performance_summary')
        assert hasattr(report, 'alerts')
        assert hasattr(report, 'issues_detected')
        assert hasattr(report, 'recommendations')
        assert hasattr(report, 'response_time_ms')
        
        # Verify metrics are collected
        assert len(report.metrics) >= 4  # At least basic components
        
        # Verify response time is reasonable
        assert report.response_time_ms < 10000  # Should complete within 10 seconds
        
        # Check that we have expected components
        expected_components = ['system_performance', 'rate_limiter', 'jwt_service', 'database_session']
        for component in expected_components:
            assert component in report.metrics, f"Missing component: {component}"

    async def test_health_check_detects_slow_database(self, health_monitor, mock_session):
        """Test that health check detects slow database responses"""
        # Mock slow database response
        async def slow_execute(*args, **kwargs):
            await asyncio.sleep(4)  # 4 second delay
            mock_result = Mock()
            mock_result.scalar.return_value = 1
            mock_result.first.return_value = Mock(
                total_connections=10,
                active_connections=5,
                idle_connections=5,
                idle_in_transaction=0,
                long_running_queries=0,
                very_long_queries=0,
                max_query_duration_seconds=1.5
            )
            return mock_result
        
        mock_session.execute.side_effect = slow_execute
        
        # Run health check
        report = await health_monitor.run_comprehensive_middleware_health_check(mock_session)
        
        # Verify slow database is detected
        assert 'database_session' in report.metrics
        db_metric = report.metrics['database_session']
        assert db_metric.status in [HealthStatus.DEGRADED, HealthStatus.CRITICAL]
        assert db_metric.response_time_ms > 3000  # Should show high response time
        
        # Verify alerts are generated for slow database
        assert len(report.alerts) > 0
        assert any('database' in alert.lower() or 'timeout' in alert.lower() for alert in report.alerts)

    async def test_health_check_detects_system_resource_issues(self, health_monitor, mock_session):
        """Test that health check detects high system resource usage"""
        # Mock high CPU and memory usage
        with patch('psutil.cpu_percent') as mock_cpu, \
             patch('psutil.virtual_memory') as mock_memory, \
             patch('psutil.disk_usage') as mock_disk:
            
            mock_cpu.return_value = 95  # Critical CPU usage
            mock_memory.return_value = Mock(
                percent=92,  # Critical memory usage
                available=100 * 1024 * 1024  # 100MB available
            )
            mock_disk.return_value = Mock(
                percent=75,  # Normal disk usage
                free=10 * 1024 * 1024 * 1024  # 10GB free
            )
            
            # Run health check
            report = await health_monitor.run_comprehensive_middleware_health_check(mock_session)
            
            # Verify system performance issues are detected
            assert 'system_performance' in report.metrics
            sys_metric = report.metrics['system_performance']
            assert sys_metric.status in [HealthStatus.DEGRADED, HealthStatus.CRITICAL]
            
            # Verify appropriate alerts are generated
            assert len(report.alerts) > 0
            assert any('cpu' in alert.lower() or 'memory' in alert.lower() for alert in report.alerts)

    async def test_health_check_timeout_detection(self, health_monitor, mock_session):
        """Test that health checks can detect conditions that could cause timeouts"""
        # Create a scenario with multiple slow components
        with patch('app.core.rate_limiter.rate_limiter.check_rate_limit') as mock_rate_limit, \
             patch('app.core.jwt_security.create_secure_token_pair') as mock_jwt:
            
            # Mock slow rate limiter (simulating Redis issues)
            async def slow_rate_limit(*args, **kwargs):
                await asyncio.sleep(3)  # 3 second delay
                return True, {'limit': 100, 'remaining': 50, 'reset_time': int(time.time()) + 3600, 'retry_after': 0, 'window': 3600}
            
            # Mock slow JWT creation
            def slow_jwt(*args, **kwargs):
                time.sleep(2)  # 2 second delay
                return {'access_token': 'test_token', 'refresh_token': 'test_refresh'}
            
            mock_rate_limit.side_effect = slow_rate_limit
            mock_jwt.side_effect = slow_jwt
            
            # Also mock slow database
            async def slow_db_execute(*args, **kwargs):
                await asyncio.sleep(2.5)  # 2.5 second delay
                mock_result = Mock()
                mock_result.scalar.return_value = 1
                mock_result.first.return_value = Mock(
                    total_connections=10,
                    active_connections=5,
                    idle_connections=5,
                    idle_in_transaction=0,
                    long_running_queries=0,
                    very_long_queries=0,
                    max_query_duration_seconds=1.5
                )
                return mock_result
            
            mock_session.execute.side_effect = slow_db_execute
            
            # Run health check
            report = await health_monitor.run_comprehensive_middleware_health_check(mock_session)
            
            # Verify timeout risk is detected
            timeout_risk_detected = False
            for metric in report.metrics.values():
                if metric.response_time_ms and metric.response_time_ms > 5000:
                    timeout_risk_detected = True
                    break
            
            # Alternative check: look for critical alerts about timeouts
            timeout_alerts = [alert for alert in report.alerts if 'timeout' in alert.lower() or 'critical' in alert.lower()]
            
            assert timeout_risk_detected or len(timeout_alerts) > 0, \
                f"Failed to detect timeout risk. Metrics: {[(name, m.response_time_ms) for name, m in report.metrics.items()]}, Alerts: {report.alerts}"

    def test_health_history_tracking(self, health_monitor):
        """Test that health history is properly tracked"""
        # Create mock health reports
        mock_reports = []
        for i in range(5):
            report = Mock()
            report.overall_status = HealthStatus.HEALTHY if i < 3 else HealthStatus.DEGRADED
            report.timestamp = datetime.utcnow() - timedelta(minutes=i)
            report.response_time_ms = 500 + i * 100
            report.performance_summary = {'healthy_components': 4, 'components_checked': 5}
            mock_reports.append(report)
        
        # Add reports to history
        for report in mock_reports:
            health_monitor._store_health_history(report)
        
        # Verify history is stored
        history = health_monitor.get_health_history()
        assert len(history) == 5
        
        # Test trend analysis
        trends = health_monitor.get_health_trends(hours=1)
        assert 'total_checks' in trends
        assert trends['total_checks'] == 5

    def test_performance_threshold_configuration(self, health_monitor):
        """Test that performance thresholds are properly configured"""
        thresholds = health_monitor.performance_thresholds
        
        # Verify critical thresholds are set to detect 8-15+ second timeout conditions
        assert thresholds['response_time_critical'] <= 5000, "Critical threshold too high to detect timeout risk"
        assert thresholds['database_connection_critical'] <= 3000, "DB threshold too high"
        assert thresholds['redis_response_critical'] <= 2000, "Redis threshold too high"
        
        # Verify warning thresholds are set to provide early warning
        assert thresholds['response_time_warning'] <= 2000, "Warning threshold should be lower"
        assert thresholds['database_connection_warning'] <= 1000, "DB warning threshold should be lower"


class TestSecurityMiddlewareHealthChecker:
    """Test security middleware health checking"""

    @pytest.fixture
    def security_checker(self):
        return SecurityMiddlewareHealthChecker()

    async def test_authentication_middleware_health(self, security_checker):
        """Test authentication middleware health check"""
        with patch('app.core.jwt_security.create_secure_token_pair') as mock_create, \
             patch('app.core.jwt_security.validate_jwt_token') as mock_validate, \
             patch('app.services.auth_jwt_service.AuthJWTService') as mock_service:
            
            # Mock successful token operations
            mock_create.return_value = {'access_token': 'test_token', 'refresh_token': 'test_refresh'}
            mock_validate.return_value = {'sub': 'auth_health_test', 'jti': 'test_jti'}
            mock_service.return_value.create_tokens_for_user.return_value = {'access_token': 'service_token'}
            
            # Run health check
            metric = await security_checker.check_authentication_middleware()
            
            # Verify metric
            assert metric.name == "authentication_middleware"
            assert metric.status in [HealthStatus.HEALTHY, HealthStatus.DEGRADED]
            assert metric.response_time_ms is not None
            assert metric.response_time_ms < 5000  # Should complete within 5 seconds

    async def test_authentication_middleware_slow_response(self, security_checker):
        """Test detection of slow authentication middleware"""
        with patch('app.core.jwt_security.create_secure_token_pair') as mock_create, \
             patch('app.core.jwt_security.validate_jwt_token') as mock_validate:
            
            # Mock slow token operations
            def slow_create(*args, **kwargs):
                time.sleep(1.5)  # 1.5 second delay
                return {'access_token': 'test_token', 'refresh_token': 'test_refresh'}
            
            def slow_validate(*args, **kwargs):
                time.sleep(1)  # 1 second delay
                return {'sub': 'auth_health_test', 'jti': 'test_jti'}
            
            mock_create.side_effect = slow_create
            mock_validate.side_effect = slow_validate
            
            with patch('app.services.auth_jwt_service.AuthJWTService') as mock_service:
                mock_service.return_value.create_tokens_for_user.return_value = {'access_token': 'service_token'}
                
                # Run health check
                metric = await security_checker.check_authentication_middleware()
                
                # Verify slow response is detected
                assert metric.status in [HealthStatus.DEGRADED, HealthStatus.CRITICAL]
                assert metric.response_time_ms > 2000  # Should show cumulative delay

    async def test_security_event_logging_health(self, security_checker):
        """Test security event logging health check"""
        with patch('app.core.audit_logging.SecurityAuditLogger') as mock_logger, \
             patch('os.path.exists') as mock_exists, \
             patch('os.access') as mock_access:
            
            # Mock healthy logging system
            mock_logger_instance = Mock()
            mock_logger_instance.log_security_event = AsyncMock()
            mock_logger.return_value = mock_logger_instance
            
            mock_exists.return_value = True
            mock_access.return_value = True
            
            # Run health check
            metric = await security_checker.check_security_event_logging()
            
            # Verify metric
            assert metric.name == "security_event_logging"
            assert metric.status in [HealthStatus.HEALTHY, HealthStatus.DEGRADED]
            assert metric.response_time_ms is not None


class TestDatabaseMiddlewareHealthChecker:
    """Test database middleware health checking"""

    @pytest.fixture
    def database_checker(self):
        return DatabaseMiddlewareHealthChecker()

    @pytest.fixture
    async def mock_session_advanced(self):
        """Advanced mock session with more detailed responses"""
        session = AsyncMock(spec=AsyncSession)
        
        # Mock different query responses
        def create_mock_result(data):
            result = Mock()
            if isinstance(data, dict):
                # Single row result
                row = Mock()
                for key, value in data.items():
                    setattr(row, key, value)
                result.first.return_value = row
                result.scalar.return_value = list(data.values())[0] if data else None
            else:
                # Simple scalar result
                result.scalar.return_value = data
            return result
        
        async def mock_execute(sql):
            sql_text = str(sql).lower()
            
            if "select 1" in sql_text:
                return create_mock_result(1)
            elif "pg_stat_activity" in sql_text and "count(*)" in sql_text:
                return create_mock_result({
                    'total_connections': 15,
                    'active_connections': 8,
                    'idle_connections': 7,
                    'idle_in_transaction': 0,
                    'long_running_queries': 1,
                    'very_long_queries': 0,
                    'max_query_duration_seconds': 45.2
                })
            elif "pg_database_size" in sql_text:
                return create_mock_result({
                    'db_size': 1024*1024*1024,  # 1GB
                    'slow_queries': 2,
                    'blocked_queries': 0
                })
            elif "information_schema.tables" in sql_text:
                return create_mock_result(25)  # 25 tables
            elif "pg_stat_user_indexes" in sql_text:
                # Return empty result for index stats
                result = Mock()
                result.fetchall.return_value = []
                return result
            elif "pg_stat_statements" in sql_text:
                # Return empty result for slow queries
                result = Mock()
                result.fetchall.return_value = []
                return result
            else:
                return create_mock_result(1)
        
        session.execute.side_effect = mock_execute
        return session

    async def test_connection_pool_health_check(self, database_checker, mock_session_advanced):
        """Test database connection pool health check"""
        metric = await database_checker.check_connection_pool_health(mock_session_advanced)
        
        # Verify metric
        assert metric.name == "database_connection_pool"
        assert metric.status in [HealthStatus.HEALTHY, HealthStatus.DEGRADED]
        assert metric.response_time_ms is not None
        assert metric.details is not None
        
        # Verify connection pool details
        details = metric.details
        assert 'total_connections' in details
        assert 'active_connections' in details
        assert 'connectivity_time_ms' in details

    async def test_database_performance_degradation_detection(self, database_checker, mock_session_advanced):
        """Test detection of database performance issues"""
        # Mock slow database operations
        original_execute = mock_session_advanced.execute.side_effect
        
        async def slow_execute(sql):
            await asyncio.sleep(2)  # 2 second delay for each query
            return await original_execute(sql)
        
        mock_session_advanced.execute.side_effect = slow_execute
        
        metric = await database_checker.check_connection_pool_health(mock_session_advanced)
        
        # Should detect slow database
        assert metric.status in [HealthStatus.DEGRADED, HealthStatus.CRITICAL]
        assert metric.response_time_ms > 2000

    async def test_query_performance_check(self, database_checker, mock_session_advanced):
        """Test database query performance checking"""
        metric = await database_checker.check_query_performance(mock_session_advanced)
        
        # Verify metric
        assert metric.name == "database_query_performance"
        assert metric.status in [HealthStatus.HEALTHY, HealthStatus.DEGRADED, HealthStatus.CRITICAL]
        assert metric.response_time_ms is not None
        assert metric.details is not None
        
        # Verify query performance details
        details = metric.details
        assert 'query_tests' in details
        assert 'max_query_time_ms' in details


class TestCacheMiddlewareHealthChecker:
    """Test cache middleware health checking"""

    @pytest.fixture
    def cache_checker(self):
        return CacheMiddlewareHealthChecker()

    async def test_redis_cache_health_check_no_redis(self, cache_checker):
        """Test Redis health check when Redis is not configured"""
        # Ensure Redis client is None
        cache_checker.redis_client = None
        
        metric = await cache_checker.check_redis_cache_health()
        
        # Should handle missing Redis gracefully
        assert metric.name == "redis_cache"
        assert metric.status == HealthStatus.DEGRADED
        assert "not configured" in metric.message

    async def test_redis_cache_health_check_with_redis(self, cache_checker):
        """Test Redis health check with mocked Redis"""
        # Mock Redis client
        mock_redis = Mock()
        mock_redis.ping.return_value = True
        mock_redis.set.return_value = True
        mock_redis.get.return_value = "health_test_value_123"
        mock_redis.delete.return_value = 1
        mock_redis.info.return_value = {
            'used_memory': 1024*1024,  # 1MB
            'maxmemory': 1024*1024*100,  # 100MB
            'connected_clients': 5,
            'total_commands_processed': 1000,
            'keyspace_hits': 800,
            'keyspace_misses': 200,
            'redis_version': '6.0.0',
            'used_memory_human': '1M'
        }
        
        cache_checker.redis_client = mock_redis
        
        metric = await cache_checker.check_redis_cache_health()
        
        # Verify metric
        assert metric.name == "redis_cache"
        assert metric.status in [HealthStatus.HEALTHY, HealthStatus.DEGRADED]
        assert metric.response_time_ms is not None
        assert metric.details is not None
        
        # Verify Redis operation details
        details = metric.details
        assert 'ping_time_ms' in details
        assert 'set_time_ms' in details
        assert 'get_time_ms' in details
        assert 'data_integrity' in details
        assert details['data_integrity'] == True

    async def test_redis_cache_slow_response_detection(self, cache_checker):
        """Test detection of slow Redis responses"""
        # Mock slow Redis client
        mock_redis = Mock()
        
        def slow_ping():
            time.sleep(1.5)  # 1.5 second delay
            return True
        
        def slow_operation(*args, **kwargs):
            time.sleep(0.8)  # 0.8 second delay per operation
            if args and args[0] == "health_check_test":
                return "health_test_value"
            return True
        
        mock_redis.ping.side_effect = slow_ping
        mock_redis.set.side_effect = slow_operation
        mock_redis.get.side_effect = lambda key: "health_test_value_" + str(int(time.time()))
        mock_redis.delete.side_effect = slow_operation
        mock_redis.info.return_value = {
            'used_memory': 1024*1024,
            'maxmemory': 1024*1024*100,
            'connected_clients': 5,
            'total_commands_processed': 1000,
            'keyspace_hits': 800,
            'keyspace_misses': 200,
            'redis_version': '6.0.0',
            'used_memory_human': '1M'
        }
        
        cache_checker.redis_client = mock_redis
        
        metric = await cache_checker.check_redis_cache_health()
        
        # Should detect slow Redis
        assert metric.status in [HealthStatus.DEGRADED, HealthStatus.CRITICAL]
        assert metric.response_time_ms > 1000  # Should show cumulative delay


class TestHealthAlertManager:
    """Test the health alert management system"""

    @pytest.fixture
    def alert_manager(self):
        return HealthAlertManager()

    async def test_alert_generation_for_unhealthy_system(self, alert_manager):
        """Test that alerts are generated for unhealthy systems"""
        # Create mock unhealthy health report
        mock_report = Mock()
        mock_report.overall_status = HealthStatus.UNHEALTHY
        mock_report.timestamp = datetime.utcnow()
        mock_report.response_time_ms = 15000  # 15 seconds - critical timeout risk
        mock_report.alerts = ["CRITICAL: System unhealthy"]
        mock_report.issues_detected = ["Multiple components failing"]
        mock_report.recommendations = ["Restart services immediately"]
        mock_report.metrics = {
            'database_session': Mock(
                status=HealthStatus.UNHEALTHY,
                response_time_ms=12000,
                message="Database connection timeout"
            )
        }
        
        # Process health report
        triggered_alerts = await alert_manager.process_health_report(mock_report)
        
        # Verify alerts are generated
        assert len(triggered_alerts) > 0
        
        # Check for critical system alert
        system_alerts = [alert for alert in triggered_alerts if 'system' in alert.title.lower()]
        assert len(system_alerts) > 0
        
        # Verify alert severity
        critical_alerts = [alert for alert in triggered_alerts if alert.severity == AlertSeverity.CRITICAL]
        assert len(critical_alerts) > 0

    async def test_alert_generation_for_timeout_risk(self, alert_manager):
        """Test that alerts are generated for timeout risk conditions"""
        # Create mock health report with timeout risk
        mock_report = Mock()
        mock_report.overall_status = HealthStatus.DEGRADED
        mock_report.timestamp = datetime.utcnow()
        mock_report.response_time_ms = 8000  # 8 seconds - approaching timeout
        mock_report.alerts = ["WARNING: High response times"]
        mock_report.issues_detected = ["Components responding slowly"]
        mock_report.recommendations = ["Investigate performance bottlenecks"]
        mock_report.metrics = {
            'rate_limiter': Mock(
                status=HealthStatus.DEGRADED,
                response_time_ms=6000,  # 6 seconds - timeout risk
                message="Rate limiter slow"
            )
        }
        
        # Process health report
        triggered_alerts = await alert_manager.process_health_report(mock_report)
        
        # Verify timeout risk alerts
        timeout_alerts = [alert for alert in triggered_alerts 
                         if 'timeout' in alert.title.lower() or 'performance' in alert.title.lower()]
        assert len(timeout_alerts) > 0

    def test_alert_cooldown_mechanism(self, alert_manager):
        """Test that alert cooldown prevents spam"""
        # Trigger the same alert multiple times
        rule_name = "test_rule"
        
        # First trigger - should not be in cooldown
        assert not alert_manager._is_in_cooldown(rule_name)
        
        # Set cooldown
        alert_manager.cooldown_tracker[rule_name] = datetime.utcnow() + timedelta(minutes=5)
        
        # Second trigger - should be in cooldown
        assert alert_manager._is_in_cooldown(rule_name)

    def test_alert_history_tracking(self, alert_manager):
        """Test that alert history is properly maintained"""
        # Create test alert
        alert = Alert(
            id="test_alert_123",
            title="Test Alert",
            message="Test alert message",
            severity=AlertSeverity.MEDIUM,
            component="test_component",
            timestamp=datetime.utcnow()
        )
        
        # Add to history
        alert_manager.alert_history.append(alert)
        
        # Verify history retrieval
        history = alert_manager.get_alert_history(limit=10)
        assert len(history) == 1
        assert history[0].id == "test_alert_123"

    def test_alert_acknowledgement(self, alert_manager):
        """Test alert acknowledgement functionality"""
        # Create and store test alert
        alert = Alert(
            id="test_ack_alert",
            title="Test Acknowledgement Alert",
            message="Test alert for acknowledgement",
            severity=AlertSeverity.HIGH,
            component="test_component",
            timestamp=datetime.utcnow()
        )
        
        alert_manager.active_alerts[alert.id] = alert
        
        # Acknowledge alert
        result = alert_manager.acknowledge_alert(alert.id, "test_user")
        assert result == True
        
        # Verify acknowledgement is recorded
        assert len(alert.acknowledgements) == 1
        assert "test_user" in alert.acknowledgements[0]


class TestHealthCheckIntegration:
    """Integration tests for the complete health check system"""

    async def test_end_to_end_health_check_flow(self, mock_session):
        """Test the complete end-to-end health check flow"""
        # Run comprehensive health check
        report = await middleware_health_monitor.run_comprehensive_middleware_health_check(mock_session)
        
        # Verify report is generated
        assert report is not None
        assert report.overall_status in [status for status in HealthStatus]
        
        # Process through alert manager
        alerts = await health_alert_manager.process_health_report(report)
        
        # Verify integration works
        assert isinstance(alerts, list)  # Should return list even if empty

    async def test_performance_regression_detection(self):
        """Test that the system can detect performance regressions over time"""
        # This would require historical data, so we'll test the structure
        trends = middleware_health_monitor.get_health_trends(hours=1)
        
        # Verify trend analysis structure
        assert isinstance(trends, dict)
        # Note: Actual trend analysis requires historical data

    def test_health_check_configuration_validation(self):
        """Test that health check thresholds are configured to prevent 8-15s timeouts"""
        thresholds = middleware_health_monitor.performance_thresholds
        
        # Critical validation: Thresholds must be set to detect issues before 8-second mark
        assert thresholds['response_time_critical'] <= 5000, \
            "Critical threshold too high - won't detect 8-15s timeout risk in time"
        
        assert thresholds['response_time_warning'] <= 2000, \
            "Warning threshold too high - need early warning before critical issues"
        
        assert thresholds['database_connection_critical'] <= 3000, \
            "Database critical threshold too high for timeout prevention"

    async def test_mobile_app_integration_compatibility(self):
        """Test that health check responses are compatible with mobile app expectations"""
        # This test would verify the API response format matches mobile app expectations
        # For now, we'll test the structure
        
        # Mock a health check response structure
        mock_response = {
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'middleware': {
                'overall_status': 'healthy',
                'metrics': {},
                'performance_summary': {},
                'response_time_ms': 500.0
            },
            'alerts': [],
            'issues_detected': [],
            'recommendations': [],
            'message': 'All systems operational'
        }
        
        # Verify required fields for mobile app
        required_fields = ['status', 'timestamp', 'middleware', 'alerts', 'message']
        for field in required_fields:
            assert field in mock_response, f"Missing required field for mobile app: {field}"

    def test_prometheus_metrics_format(self):
        """Test that health metrics are properly formatted for Prometheus"""
        # Test metric naming and format
        expected_metrics = [
            'mita_middleware_health_status',
            'mita_middleware_component_health',
            'mita_middleware_component_response_time_ms',
            'mita_middleware_alerts_count',
            'mita_middleware_issues_count'
        ]
        
        # This would test actual Prometheus endpoint in integration
        # For unit test, we verify the structure exists
        assert len(expected_metrics) > 0


if __name__ == "__main__":
    # Run tests with pytest
    pytest.main([__file__, "-v", "--tb=short"])